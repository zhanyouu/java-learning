# Spring是如何解决循环依赖的问题的？

三级缓存，提前暴露对象，aop

**总**：什么是循环依赖问题，A依赖B，B依赖C，C依赖A

**分**：先说明bean得创建过程：实例化，初始化（填充属性）

​		1.先创建A对象，实例化A对象，此时A对象中的b属性为空

​		2.从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题(不通)，找不到直接创建B对象

​		3.实例化B对象，此时B对象中的a属性为空，填充属性a

​		4.从容器中查找A对象，找不到，直接创建

​		此时，如果仔细琢磨的话，会发现A对象，是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象的引用，所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的关键，

​	当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几种状态，完成实例化=但未完成初始化，完整状态，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方式来查找的。一级缓存中放的是完整对象，二级缓存中放的是非完整对象，

​	为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口

，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。

​	如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要

​	普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()

​	因此，所有的bean对象在创建的时候要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象

### 三级缓存是如何解决AOP的循环依赖问题的？
    1、首先Bean的实例化和初始化时分开的，bean对象的代理是在实例化后的后置增强器中完成的。bean对象在实例化的时候（向外暴露对象时）不知道自己是否需要被代理，因此选择向外暴露一个BeanFactory的lambda表达式，
    在被使用的时候通过getObject方法（回调机制）获取对象时来判断是否需要代理。
    2、Bean对象在实例化的时候不知道是否存在循环依赖问题，如果提前暴露代理对象的话，如果不存在循环依赖的话，违背了代理对象的设计原则。
    