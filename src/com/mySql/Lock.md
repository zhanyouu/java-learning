

### 全局锁
顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
### 表锁
MyISAM引擎默认锁

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
### 行锁
InnoDB默认锁，作用在索引上
#### 共享锁-读锁（S锁）
允许一个事物去读取一行数据（但是不允许修改），阻止其它事物对该行数据获得排他锁（其它事物不能修改记录）；
#### 排他锁-写锁（X锁）
允许一个事物去更新一行数据，阻止其它事物对该数据获得共享锁和排他锁（其它事物不能修改记录）；
### 意向共享锁（表锁）
一个事务给一个数据行加共享锁时，会相应的给表加IS锁。（事物想要获取共享锁时，先要获取表上的IS锁）
### 意向排他锁（表锁）
作用：当一个事物要准备去获取一行记录的排他锁时，不用去挨个查询判断该行记录有没有被加排它锁，直接去获取所在表的意向排他锁。

一个事务给一个数据行加排他锁时，会相应的给表加IX锁。（事物想要获取排他锁时，先要获取表上的IX锁）
### 记录锁（Record Lock）
记录锁锁住的是索引记录。如果使用索引作为条件命中了记录，那么就是记录锁，被锁住的记录不能被别的事务插入相同的索引键值，修改和删除。

我们在表中插入4条记录，主键分别是1、4、7、10。 我们用主键或者唯一索引作为条件等值查询的时候，命中记录就是加的记录锁，如：
select * from xx where id = 1; 命中记录，所以id = 1这条记录就加了记录锁。
### 间隙锁（Gap Lock）（左开右开）
锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 间隙锁是锁在索引之间或者第一个索引前面或者最后一个索引后面。 当我们使用索引无论是等值还是范围查询，没有命中一条记录时候，加的就是间隙锁。
还是拿上面的例子，我们在表中插入4条记录，主键分别是1、4、7、10。
select * from xx where id = 6 或者 select * from xx were id >4 and id < 7;
没有命中任何一条记录，会锁住（4，7）区间，另一个事务插入id = 6则会阻塞；
select * from xx where id > 20没有命中，会锁住（10，正无穷），另一个事务插入id = 11会阻塞。
### 临键锁（Next-Key Lock）（记录锁和间隙锁的组合，左开右闭）
当我们使用索引进行范围查询，命中了记录的情况下，就是使用了临键锁，他相当于记录锁+间隙锁。
两种退化的情况：
唯一性索引，等值查询匹配到一条记录的时候，退化成记录锁。
没有匹配到任何记录的时候，退化成间隙锁。
左开右闭区间，目的是为了解决幻读的问题。
select * from xx where id > 5 and id < 9;
上面的sql命中了id = 7的记录，也包含了记录不存在的区间，所以他锁住（4，7]和（7，10]区间，在这区间，别的事务插入不了数据，所以解决了幻读问题。
### 乐观锁
在分布式情况下，表中行记录并发写请求较少，通过版本号来控制并发更新，如果更新失败，则回滚。
### 悲观锁
在分布式情况下，表中行记录并发更新较多，需要获取锁才能更新操作。